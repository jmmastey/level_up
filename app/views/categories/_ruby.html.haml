%p It's easy to get into the magic of rails and forget that the underlying language, ruby, is also a beautiful thing. Philosophically, ruby and rails share a lot of the same predilections: they both value terse, expressive syntax, they have a strong open source, test-focused community, and they're full of both elegant and scary magic. It's easy to do great things with ruby, but it's also very easy to make a mess. Let's build a basis of clean ruby to prevent trouble down the road.

.page-header
  %h3 Ruby Core
  %p Take some time to practice with ruby core. There are a million tutorials around to teach you the basics, but once you've experienced the really simple stuff (arrays and hashes and variables and iteration), you'll find that the most important thing to do is to write a lot of ruby. If you need suggestions, try Ruby Koans, or Exercism.io. It's hard to see some of the problems we'll talk about until you have a little code written.
  %p Also, after several years of writing ruby programs, I still find myself opening the official ruby docs for core classes to find the right method to turn my code into something simple and capable.

  = exercise_block_for "docs" do |e|
    - e.question "Ruby core has so many more methods than you'll ever keep in your head. That's totally fine, but you need to know how to look up and use those functions. Use the ruby docs to find the docs for the String class. There's a method that lets you substitute a bunch of characters for a corresponding set of characters (it's not gsub). Find that method and use it in a code sample"


.page-header
  %h3 Stylish (and Sane) Ruby
  %p Since ruby is dynamically typed and also extremely terse, it's easy to get into trouble after writing relatively little code. It's not so much that ruby gives you a gun to shoot yourself with, it also insists on pointing that gun at your foot. There are some simple heuristics we've learned to use over time that make it possible to continue working with your code for a while, not to mention working in a large team. Just remember, they have guns too.

  %p The first, most obvious thing is to standardize on a single way of writing ruby. Because the syntax is so flexible, there are typically many ways to write a given program. Instead, we should usually follow the conventions of the popular Ruby Style Guide. That said, remember that clarity is always key, so if a particular piece of code is more comprehensible, it can make sense to break the rules.

  = exercise_block_for "style_guide" do |e|
    - e.question "Fix the code example in the #{exercise_link 'triangle_facts'} exercise so that it conforms to the Ruby style guide."

  %p Another common pattern that is both common and totally unnecessary is called Arrowhead Programming. this is pretty simple to diagnose. If a method indents more than maybe two levels, it probably needs to be refactored. Method calls are cheap relative to other resources, so reorganizing and refactoring your code to avoid this particular problem is well worth it.

  = resource_block do |e|
    - e.video("Sandi Metz - Rules", 'https://www.youtube.com/watch?v=npOGOmkxuio', "A discussion of this and the next few ideas.")

  = exercise_block_for "arrowhead" do |e|
    - e.question "Look at the code in the #{exercise_link 'arrowhead'} exercise. It currently fails to put error conditions near their conditions. Refactor it so that it isn't terrible anymore."

  %p The next rule turns out to be related to the previous one: you should write short methods, and short lines of code. Games like code golf are lots of fun, but if you check abstruse one-liners into the production codebase you're mostly just a jerk. A decent rule of thumb is to have no more than five lines of code in a method, and to keep your lines of code under eighty characters. That said, it's still possible to write a lot of terrible code in eighty characters, so consider rewriting any line whose meaning is not entirely apparent.

  = resource_block do |e|
    - e.book("Practical Object Oriented Design in Ruby (POODR)", 'http://smile.amazon.com/dp/0321721330', "Sandi Metz's (sense a theme?) book on designing good objects and messages.")
    - e.book("Confident Ruby", 'https://www.confidentruby.com/', "How to structure just one method. Fantastic book.")

  = exercise_block_for "short_methods" do |e|
    - e.question "We're going to continue rocking these exercises. The #{exercise_link 'robot_name'} exercise seems apropos here."

  %p Even with short lines of code, it's not always possible to understand all code at a glance, so we put a lot of focus on using meaningful variable and method names. Ideally, someone reading your code should not even need to look at the body of a method to know what it does; the name should stand alone sufficiently to describe it. Similarly, variable names serve either to enlighten or confuse others as they read your code.

  = resource_block do |e|
    - e.video("Naming - Head Count", 'https://www.rubytapas.com/2013/04/22/episode-087-naming-things-headcount/', "Naming is always going to be hard (it's actually stated as one of the hard problems of computer science), but this Tapas does a good job walking you through some ideas on the topic.")
    - e.video("What's in a Name", 'www.sitepoint.com/whats-in-a-name-anti-patterns-to-a-hard-problem/', "A short article on some specific rules you can use to decide how to name a thing.")

  = exercise_block_for "meaningful_names" do |e|
    - e.question "You're never going to guess how this goes. Refactor your ruby code!"

  %p Finally, once you've written your masterpiece code, it's important to remember that conciseness in the code has to be less important than others' ability to understand it. You should already be doing code review with your peers (and hopefully with people with much more experience than yourself). If they don't understand the code quickly, it means that you won't either a month from now, and that's a problem.

  = exercise_block_for "fivesecond" do |e|
    - e.question "Explain how the Five Second Rule for code review works."

.page-header
  %h3 Comments (and Why We Tend to Avoid Them)

  %blockquote
    %p The question of whether to comment is a legitimate one. Done poorly, commenting is a waste of time and sometimes harmful. Done well, commenting is worthwhile.
    %small Steve McConnell

  %p With all this talk about confusion about methods, you might be forgiven for suggesting that we just document everything with comments. Indeed, if you come from a Java education, you may be experienced in writing long javadoc for every function and object describing the exact usage of that function. In ruby, we avoid this for a few reasons. The first, a problem that all languages share, is that comments go stale very quickly. It's almost a truism that if there's a comment for a method that it will be out of date as soon as it's written.

  %p The second reason is that over-commenting (and overspecifying) behavior in ruby reduces our ability to use "duck-typing" and dynamic behavior in our code. Philosophically, languages like Java prescribe (and proscribe) behavior based on types, classes, and enforced contracts, but one of the most powerful aspects of ruby is that we don't nail down our inputs and outputs as much. By calcifying our code with contracts, we lose our advantage.

  %p Finally, we try to be as "Agile" as possible when we write applications, and while that doesn't mean that we skip comments entirely, it does mean that we hesitate to generate documentation when it's not totally necessary. Good code (and its tests) should stand as documentation of its own function.

  = resource_block do |e|
    - e.text("Wikipedia - Self Documenting Code", 'https://en.wikipedia.org/wiki/Self-documenting', "As always, the wiki page.")
    - e.audio("Ruby Rogues - Documenting Code", 'http://rubyrogues.com/079-rr-documenting-code/', "This podcast explains better and with more relevant examples than the wiki page.")

  = exercise_block_for "comments" do |e|
    - e.question "Take a break from the code for a minute. Explain why we say that 'comments lie'."
    - e.question "If we don't trust comments, how do we explain our code adequately to others?"
    - e.question "Explain what 'self documenting code' means in your own words"

  = exercise_block_for "comments2" do |e|
    - e.question "So, I lied above obviously. Sometimes comments are actually necessary. Name (and defend) some cases where you should add comments to your code."

.page-header
  %h3 Tying It All Together

  %p Now that you've got all the basics tied together, it's time to write a substantial program. This will be the first big complete program you're asked to write as part of this course.

  %p Especially if you're still inexperienced, <b>don't get disheartened</b>. A big part of effective development is learning to break down this sort of problem. Try separating out one requirement (say, parsing data files) and writing a separate class to accomplish this task. Before long you'll have settled all the issues and have working code.

  = exercise_block_for "ruby_core" do |e|
    - e.question "Do the #{exercise_link 'dino_catalog'} exercise."
    - e.question "If you get stuck, ask for help on Slack."
    - e.question "Look up again and make sure that your dino_catalog code is self-documenting, stylish, uses meaningful names, and has no arrowheads."
